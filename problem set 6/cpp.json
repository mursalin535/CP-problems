{
  "Basic C++ Template": {
    "prefix": "cppbasic",
    "body": [
      "#include <iostream>",
      "",
      "using namespace std;",
      "",
      "int main() {",
      "    // Your code here",
      "    return 0;",
      "}"
    ],
    "description": "Basic C++ template with iostream"
  },

  "Competitive Programming Template": {
    "prefix": "cppfull",
    "body": [
      "#include <bits/stdc++.h>",
      "",
      "using namespace std;",
      "",
      "int main() {",
      "    // Your code here",
      "    return 0;",
      "}"
    ],
    "description": "C++ template for competitive programming"
  },

  "Competitive Programming With Test Cases": {
    "prefix": "cppt",
    "body": [
      "#include <bits/stdc++.h>",
      "",
      "using namespace std;",
      "",
      "int main() {",
      "    int t; cin >> t;",
      "    while(t--) {",
      "        // test case logic",
      "    }",
      "    return 0;",
      "}"
    ],
    "description": "C++ CP template with test cases"
  },

  "Bisection Method": {
    "prefix": "bisection",
    "body": [
      "#include <iostream>",
      "#include <iomanip>",
      "#include <cmath>",
      "using namespace std;",
      "double func(double x) {",
      "    return pow(x, 3) - x - 1;",
      "}",
      "void bisection(double a, double b, double tol) {",
      "    if (func(a) * func(b) >= 0) {",
      "        cout << \"Invalid initial guesses. f(a) and f(b) must have opposite signs.\" << endl;",
      "        return;",
      "    }",
      "    cout << left << setw(5) << \"Iter\" << setw(12) << \"a\" << setw(12) << \"b\" << setw(12) << \"m\" << setw(12) << \"f(m)\" << endl;",
      "    int iteration = 1;",
      "    double m;",
      "    while ((b - a) / 2 > tol) {",
      "        m = (a + b) / 2.0;",
      "        double f_a = func(a);",
      "        double f_m = func(m);",
      "        cout << left << setw(5) << iteration << setw(12) << a << setw(12) << b << setw(12) << m << setw(12) << f_m << endl;",
      "        if (f_a * f_m < 0)",
      "            b = m;",
      "        else",
      "            a = m;",
      "        iteration++;",
      "    }",
      "    cout << \"\\nApproximate root: \" << fixed << setprecision(6) << (a + b) / 2 << endl;",
      "}",
      "int main() {",
      "    double a = 1.0, b = 2.0, tol = 0.0001;",
      "    cout << fixed << setprecision(6);",
      "    bisection(a, b, tol);",
      "    return 0;",
      "}"
    ],
    "description": "Bisection method C++ template"
  },

  "False Position Method": {
    "prefix": "false_position",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "int it = 1;",
      "double func(double x) {",
      "    return (pow(x, 3) - 2 * x - 5);",
      "}",
      "void findans(double a, double b, double e) {",
      "    if (func(a) * func(b) >= 0) {",
      "        cout << \"Invalid initial guesses\" << endl;",
      "        return;",
      "    }",
      "    double c = (a * func(b) - b * func(a)) / (func(b) - func(a));",
      "    cout << ++it << \" \" << a << \" \" << b << \" \" << c << \" \" << func(c) << endl;",
      "    if (fabs(func(c)) <= e) {",
      "        cout << \"The approximate root is \" << c << endl;",
      "        return;",
      "    }",
      "    if (func(a) * func(c) < 0)",
      "        findans(a, c, e);",
      "    else",
      "        findans(c, b, e);",
      "}",
      "int main() {",
      "    double a = 2, b = 3, e = 0.0001;",
      "    cout << \"ite\" << \" \" << \"a\" << \" \" << \"b\" << \" \" << \"c\" << \" \" << \"f(c)\" << endl;",
      "    findans(a, b, e);",
      "    return 0;",
      "}"
    ],
    "description": "False position method C++ template"
  },

  "Iteration Method": {
    "prefix": "iteration",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "int it = 1;",
      "double g(double x) {",
      "    return (1 / sqrt(x + 1));",
      "}",
      "void findans(double x0, double e) {",
      "    cout << \"ite\" << \" \" << \"x_n\" << \" \" << \"g(x_n)\" << \" \" << \"|x_(n+1) - x_n|\" << endl;",
      "    double xn = x0, xn1, diff;",
      "    do {",
      "        xn1 = g(xn);",
      "        diff = fabs(xn1 - xn);",
      "        cout << ++it << \" \" << xn << \" \" << xn1 << \" \" << diff << endl;",
      "        xn = xn1;",
      "    } while (diff > e);",
      "    cout << \"\\nThe approximate root is \" << xn1 << endl;",
      "}",
      "int main() {",
      "    double x0 = 0.5, e = 0.0001;",
      "    findans(x0, e);",
      "    return 0;",
      "}"
    ],
    "description": "Simple iteration method C++ template"
  },

  "Newton-Raphson Method": {
    "prefix": "newton_raphson",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "int it = 1;",
      "double func(double x) {",
      "    return (pow(x, 3) - 2 * x - 5);",
      "}",
      "double dfunc(double x) {",
      "    return (3 * pow(x, 2) - 2);",
      "}",
      "void findans(double x0, double e) {",
      "    cout << \"ite\" << \" \" << \"x_n\" << \" \" << \"f(x_n)\" << \" \" << \"|x_(n+1) - x_n|\" << endl;",
      "    double xn = x0, xn1, diff;",
      "    do {",
      "        double fx = func(xn);",
      "        double dfx = dfunc(xn);",
      "        if (fabs(dfx) < 1e-10) {",
      "            cout << \"Derivative too small. Method fails.\" << endl;",
      "            return;",
      "        }",
      "        xn1 = xn - fx / dfx;",
      "        diff = fabs(xn1 - xn);",
      "        cout << ++it << \" \" << xn << \" \" << fx << \" \" << diff << endl;",
      "        xn = xn1;",
      "    } while (diff > e);",
      "    cout << \"\\nThe approximate root is \" << fixed << setprecision(4) << xn << endl;",
      "}",
      "int main() {",
      "    double x0 = 2.0, e = 0.0001;",
      "    findans(x0, e);",
      "    return 0;",
      "}"
    ],
    "description": "Newton-Raphson method C++ template"
  },

  "Ramanujan Method": {
    "prefix": "ramanujan",
    "body": [
      "#include <iostream>",
      "#include <iomanip>",
      "#include <vector>",
      "using namespace std;",
      "void ramanujan_method(vector<double> coeffs, double epsilon, int max_terms = 15) {",
      "    vector<double> b;",
      "    b.push_back(0);",
      "    b.push_back(1);",
      "    int n = coeffs.size();",
      "    for (int i = 2; i < max_terms; i++) {",
      "        double bn = 0;",
      "        for (int j = 1; j <= min(i, n); j++) {",
      "            if (i - j < (int)b.size()) {",
      "                bn += coeffs[j - 1] * b[i - j];",
      "            }",
      "        }",
      "        b.push_back(bn);",
      "    }",
      "    cout << fixed << setprecision(6);",
      "    for (int i = 3; i < (int)b.size(); i++) {",
      "        cout << \"b_\" << i << \" = \" << b[i] << endl;",
      "        if (i >= 2) {",
      "            double ratio = b[i - 1] / b[i];",
      "            cout << \"b_\" << i - 1 << \" / b_\" << i << \" = \" << ratio << endl;",
      "        }",
      "    }",
      "}",
      "int main() {",
      "    vector<double> coeffs = {11.0/6.0, -1.0, 1.0/6.0};",
      "    double epsilon = 0.001;",
      "    ramanujan_method(coeffs, epsilon);",
      "    return 0;",
      "}"
    ],
    "description": "Ramanu"
  }}
